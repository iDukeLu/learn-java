# 对象及变量的并发访问
## 掌握重点
- synchronized 对象监视器为 Object 时的使用
- synchronized 对象监视器为 Class 时的使用
- 非线程安全是如何出现的
- 关键字 volatile 的主要作用
- 关键字 volatile 与 synchronized 的区别及使用情况

多个线程并发访问实例变量时，会出现脏读的现象。
如两个线程，同时操作实例变量 User，一个线程修改 User 的信息，一个线程读取 User，就可能出现读取到修改到一半的 User

**实例变量**才会出非现线程安全问题，**局部变量**和**类变量**不会出现非线程安全

多个对象多个锁
synchronized 修饰非静态方法：以对象为锁
synchronized 修饰静态方法：以类为锁
synchronized 修饰代码块：以类或对象为锁

赋值加锁，读取未加锁：保证数据修改是同步的，但可能会产生脏读

synchronized 锁重入：获取锁的线程可以在不释放锁的情况下，再次获取自己拿到的锁

出现异常，锁自动释放：程序出现异常时，线程会释放掉所有锁

同步不具有继承性：父类 synchronized 修饰的方法，子类复写后也必须使用 synchronized 修饰，才具有同步性

synchronized 同步方法的弊端：synchronized 方法的锁是当前对象，可能对相同对象的其他方法造成阻塞

synchronized 同步代码块解决同步方法的弊端：
- 分段锁：一半同步，一半异步
- 不同锁：充分利用不同对象不同锁，将操作的示例变量作为锁，而不是将当前对象 this 作为锁，可以避免同锁阻塞

非同步方法调用同步方法可能出现脏读

大多数情况下，同步代码块不使用 String 作为锁对象

volatile 关键字：强制从公共堆栈取得变量的值，而不是从私有数据栈中取得变量的值
- 保证可见性
- 不保证原子性