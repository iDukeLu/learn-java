## 进程和线程
- 进程：操作系统管理的基本运行单元
- 线程：进程中独立运行的子任务

- 单任务特点：排队执行、同步
- 多任务特点：同时执行、异步

## 使用多线程
### 1. 创建线程
- 继承 Thread 类
- 实现 Runnable 接口

### 2. 启动线程：
调用 thread.start() 方法后，线程会进入就绪状态，等待线程调度器分配线程调用 run() 方法

### 3. 停止线程：
- 自然停止：run() 方法执行完后线程自动停止
- 暴力停止：thread.stop()（已废弃）
- 使用标识停止：thread.interrupt()
    thread.interrupt()：并不会正在的打断线程，只是为线程打上中断标识。想要正在停止线程还需要配合异常（推荐）、return 或 sleep() 方法
    thread.isInterrupted()：判断某个线程是否存在中断标识，不会清除中断标识
    Thread.interrupted()：判断当前线程是否存在中断标识，并清除中断标识

thread.stop() 方法已经被废弃，原因是：
- 可能导致线程无法完成后续的清理工作；如线程在结束使需要归还连接给连接池，强制停止线程会导致连接不能被归还
- 可能导致数据得不到同步的处理，造成数据不一致的问题；如线程在执行任务到一半时被强行停止，导致剩下一部分到数据没有得到更新

### 4. 暂停线程
- thread.suspend()：已废弃；暂停线程
- thread.resume()：已废弃；恢复线程

suspend() 与 resume() 废弃原因：
- 锁独占：suspend() 方法不会释放锁，可能会造成锁独占，导致其他线程的阻塞
- 不同步：锁独占后，中途暂停线程

synchronized：可以在任意对象及方法上加锁，加锁的这段代码称为 "互斥区" 或 "临界区"

非线程安全：多个线程对同一个对象的实例进行操作，导致对象的值改变、值不同步的情况

isAlive()
sleep()
getId()
yield()

线程优先级：
设置线程优先级：thread.setPriority()
等级划分：1～10，越大优先级越高，不在范围内会抛出 IllegalArgumentException()
特性：
- 继承性：子线程会继承父线程的优先级
- 规则性：