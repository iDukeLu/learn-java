# 第三章、线程间通信
## 掌握重点
- 使用 wait/notify 实现线程间通信
- 生产者消费者模型的实现
- 方法 join 的使用
- ThreadLocal 类的使用

线程 A 执行任务，线程 B 轮训判断 A 执行时数据的变化
- 轮训时间太短：浪费 CPU 资源
- 轮训时间太长：监控不到某一刻的数据变化

阻塞、等待：都是线程挂起，不同点在于由谁来唤醒线程
- 阻塞：系统唤醒线程继续工作
- 等待：用户唤醒线程继续工作

线程的通信方式：
- 判断共享数据进行通信
- wait/notify 通信
- 待补充。。。

采用 wait/notify 机制
举例：厨师、服务员好比两个线程

wait() 方法：
- 使当前执行代码的线程进行等待
- 将当前线程置入 "预执行队列"，并在 wait() 方法处停止执行，直至接到通知或被中断为止
- 只能在同步方法或同步代码块中使用，若在调用 wait() 没有持有适当的锁，则抛出 IllegalMonitorStateException 异常
- 在调用 wait() 后，会释放当前持有的锁

notify() 方法：
- 随机唤醒一个 wait 状态的线程
- notify() 方法执行后，不会马上释放锁，整个方法执行完后才后释放锁，wait 状态的线程才能抢锁
- 只能在同步方法或同步代码块中使用，若在调用 notify() 没有持有适当的锁，则抛出 IllegalMonitorStateException 异常
- 在调用 notify() 且当前方法执行完后，会释放当前持有的锁
- 一个 notify() 只能唤醒一个 wait 状态的线程，其他 wait 状态的线程会继续等待，直到被唤醒